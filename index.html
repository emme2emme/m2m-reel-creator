<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üé¨ M2M Reel Creator ‚Äî Web</title>
  <meta name="theme-color" content="#3498db" />
  <style>
    /* === Stili dal tuo mockup, condensati === */
    * { box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); margin:0; padding:10px; color:#333 }
    .container{max-width:520px;margin:0 auto;background:rgba(255,255,255,.96);border-radius:24px;box-shadow:0 20px 40px rgba(0,0,0,.12);overflow:hidden}
    .header{background:linear-gradient(135deg,#2c3e50,#3498db);color:#fff;padding:28px 22px;text-align:center}
    .header h1{margin:0 0 8px;font-size:1.8rem}
    .content{padding:22px}
    .step{margin-bottom:22px}
    .step-header{display:flex;align-items:center;gap:10px;font-weight:700;color:#2c3e50;margin-bottom:10px}
    .step-number{width:32px;height:32px;border-radius:50%;display:grid;place-items:center;color:#fff;background:linear-gradient(135deg,#3498db,#2980b9);box-shadow:0 4px 12px rgba(52,152,219,.3)}
    .card{background:#f8f9fa;border:1px solid #e9ecef;border-radius:14px;padding:14px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .selector{border:2px dashed #dee2e6;border-radius:14px;padding:16px;text-align:center;background:#fff;cursor:pointer}
    .selector.active{border-color:#27ae60;background:#d4edda}
    .label{font-weight:600;color:#2c3e50;margin-bottom:6px}
    .desc{font-size:.85rem;color:#6c757d}
    .slider-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .pill{background:linear-gradient(135deg,#3498db,#2980b9);color:#fff;border-radius:999px;padding:4px 10px;font-weight:700;font-size:.9rem}
    input[type=range]{width:100%}
    .btn{border:0;border-radius:18px;padding:14px 18px;font-weight:800;color:#fff;cursor:pointer;display:flex;gap:8px;align-items:center;justify-content:center}
    .btn-primary{background:linear-gradient(135deg,#27ae60,#229954);box-shadow:0 8px 20px rgba(39,174,96,.28)}
    .btn-secondary{background:linear-gradient(135deg,#f39c12,#e67e22)}
    .muted{font-size:.85rem;color:#6c757d}
    .progress{display:none;margin-top:12px}
    .bar{height:12px;background:#e9ecef;border-radius:6px;overflow:hidden}
    .fill{height:100%;width:0;background:linear-gradient(90deg,#3498db,#2980b9)}
    .center{text-align:center}
    .badge{display:inline-block;background:#fff3cd;color:#856404;border-radius:999px;padding:4px 10px;font-weight:700;font-size:.8rem}
    .row{display:flex;gap:10px;align-items:center}
    .template-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px}
    .template{border:2px solid #e9ecef;border-radius:12px;padding:10px;text-align:center;background:#fff;cursor:pointer}
    .template.active{border-color:#27ae60;background:#d4edda}
    .result{display:none;margin-top:14px;padding:16px;background:#d4edda;border:1px solid #c3e6cb;border-radius:14px}
    .warn{background:#fff3f3;color:#842029;border:1px solid #f5c2c7;border-radius:12px;padding:10px;margin-top:10px}
    .code{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#f1f3f5;padding:10px;border-radius:8px;overflow:auto;font-size:.85rem}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé¨ M2M Reel Creator</h1>
      <div>Montaggio reale in-browser (Web ‚ü∑ Mobile)</div>
    </div>
    <div class="content">
      <!-- STEP 1: selezione -->
      <div class="step">
        <div class="step-header"><div class="step-number">1</div><div>Carica i tuoi file</div></div>
        <div class="grid2">
          <label class="selector" id="chooseFiles">
            <div class="label">Seleziona File</div>
            <div class="desc">Video / Immagini / Audio</div>
          </label>
          <label class="selector" id="chooseFolder">
            <div class="label">Seleziona Cartella</div>
            <div class="desc">Richiede browser Chromium</div>
          </label>
        </div>
        <div class="row" style="margin-top:8px">
          <div id="fileBadge" class="badge" style="display:none">0 file caricati</div>
          <div class="muted" id="tip">Formati consigliati: .mp4, .mov, .webm, .mkv (video); .jpg/.png (immagini)</div>
        </div>
        <input id="fileInput" type="file" multiple accept="video/*,image/*,audio/*" hidden />
        <input id="folderInput" type="file" webkitdirectory directory multiple accept="video/*,image/*,audio/*" hidden />
      </div>

      <!-- STEP 2: template -->
      <div class="step">
        <div class="step-header"><div class="step-number">2</div><div>Scegli un template</div></div>
        <div class="template-grid">
          <div class="template active" data-tmpl="custom">‚öôÔ∏è<div><b>Personalizzato</b></div><div class="muted">Imposti tu</div></div>
          <div class="template" data-tmpl="viral">üî•<div><b>Viral Reel</b></div><div class="muted">60s ‚Ä¢ clip 3s</div></div>
          <div class="template" data-tmpl="smooth">‚ú®<div><b>Smooth Flow</b></div><div class="muted">90s ‚Ä¢ clip 5s</div></div>
          <div class="template" data-tmpl="burst">‚ö°<div><b>Quick Burst</b></div><div class="muted">30s ‚Ä¢ clip 2s</div></div>
          <div class="template" data-tmpl="cinematic">üé¨<div><b>Cinematic</b></div><div class="muted">120s ‚Ä¢ clip 7s</div></div>
          <div class="template" data-tmpl="story">üì±<div><b>Story Mode</b></div><div class="muted">45s ‚Ä¢ clip 4s</div></div>
        </div>
      </div>

      <!-- STEP 3: impostazioni -->
      <div class="step card">
        <div class="slider-row"><span class="label">Durata finale</span><span class="pill" id="totalOut">60s</span></div>
        <input id="totalRange" type="range" min="15" max="180" step="5" value="60" />
        <div class="slider-row" style="margin-top:10px"><span class="label">Durata clip</span><span class="pill" id="clipOut">4s</span></div>
        <input id="clipRange" type="range" min="2" max="15" step="0.5" value="4" />
        <div class="slider-row" style="margin-top:10px"><span class="label">Clip da usare</span><span class="pill" id="countOut">10</span></div>
        <input id="countRange" type="range" min="3" max="50" step="1" value="10" />
        <div class="muted" style="margin-top:8px">Stima clip: <b id="estClips">15</b></div>
      </div>

      <!-- STEP 4: genera -->
      <div class="step">
        <div class="step-header"><div class="step-number">4</div><div>Crea il tuo montaggio</div></div>
        <button class="btn btn-primary" id="startBtn">üöÄ Crea Video</button>
        <div class="progress" id="progressBox">
          <div class="bar"><div class="fill" id="progressFill"></div></div>
          <div class="center muted" id="progressText">Preparazione‚Ä¶</div>
        </div>
        <div class="result" id="resultBox">
          <div class="center" style="font-size:2rem">üéâ</div>
          <div class="center" style="font-weight:700;color:#155724">Video pronto!</div>
          <div class="center" style="margin-top:10px">
            <a id="downloadLink" class="btn btn-secondary" download>üì• Scarica</a>
          </div>
        </div>
        <div class="warn" id="compatNote" style="display:none">
          Suggerimento: su iOS/Safari il formato prodotto √® <b>WebM</b>. Per MP4/H.264 integreremo la versione nativa (Capacitor + FFmpegKit) o un backend FFmpeg.
        </div>
      </div>

      <!-- Diagnostica -->
      <details class="step card">
        <summary><b>Dettagli tecnici</b></summary>
        <div class="muted" style="margin-top:8px">Questa versione fa il rendering via <b>Canvas + MediaRecorder</b> (stream video) e <b>WebAudio</b> (stream audio) concatenando i clip e applicando ridimensionamento 9:16. √à pensata per girare 100% in-browser senza server.</div>
        <div class="code" id="log"></div>
      </details>

      <!-- Elementi nascosti per il rendering -->
      <video id="hiddenVideo" crossorigin="anonymous" playsinline muted style="display:none"></video>
      <canvas id="stage" width="1080" height="1920" style="display:none"></canvas>
    </div>
  </div>

  <script>
    // === Utility log ===
    const $ = (sel) => document.querySelector(sel);
    const logBox = $('#log');
    const log = (...args) => { logBox.textContent += args.join(' ') + "\n"; };

    // Stato app
    const state = {
      files: [], // File[]
      picked: [], // oggetti clip scelti
      template: 'custom',
      total: 60,
      perClip: 4,
      count: 10,
      fps: 30,
      w: 1080, h: 1920,
      crossfade: 0.4,
    };

    // UI wiring
    $('#chooseFiles').onclick = () => $('#fileInput').click();
    $('#chooseFolder').onclick = () => $('#folderInput').click();
    $('#fileInput').onchange = (e) => ingest(Array.from(e.target.files));
    $('#folderInput').onchange = (e) => ingest(Array.from(e.target.files));

    document.querySelectorAll('.template').forEach(el => {
      el.onclick = () => {
        document.querySelectorAll('.template').forEach(e => e.classList.remove('active'));
        el.classList.add('active');
        state.template = el.dataset.tmpl;
        applyTemplate();
      }
    });

    $('#totalRange').oninput = (e) => { state.total = +e.target.value; $('#totalOut').textContent = state.total + 's'; estimate(); };
    $('#clipRange').oninput = (e) => { state.perClip = +e.target.value; $('#clipOut').textContent = state.perClip + 's'; estimate(); };
    $('#countRange').oninput = (e) => { state.count = +e.target.value; $('#countOut').textContent = state.count; estimate(); };

    $('#startBtn').onclick = start;

    function ingest(files){
      // Filtra solo media
      const mm = files.filter(f => /^(video|image|audio)\//.test(f.type) || /\.(mp4|mov|webm|mkv|m4v|jpg|jpeg|png|gif|bmp|webp|mp3|wav)$/i.test(f.name));
      state.files = mm;
      $('#fileBadge').style.display = 'inline-block';
      $('#fileBadge').textContent = `${mm.length} file caricati`;
      log('Caricati', mm.length, 'file');
    }

    function applyTemplate(){
      const t = state.template;
      if(t==='viral'){ state.total=60; state.perClip=3; }
      else if(t==='smooth'){ state.total=90; state.perClip=5; }
      else if(t==='burst'){ state.total=30; state.perClip=2; }
      else if(t==='cinematic'){ state.total=120; state.perClip=7; }
      else if(t==='story'){ state.total=45; state.perClip=4; }
      // custom: non tocco
      $('#totalRange').value = state.total; $('#totalOut').textContent = state.total+'s';
      $('#clipRange').value = state.perClip; $('#clipOut').textContent = state.perClip+'s';
      estimate();
    }

    function estimate(){
      const est = Math.ceil(state.total / state.perClip);
      $('#estClips').textContent = est;
    }

    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }

    async function start(){
      if(state.files.length===0){ alert('Carica prima dei file.'); return; }
      // Scegli clip casuali
      const pool = shuffle([...state.files]).slice(0, Math.min(state.count, state.files.length));
      state.picked = pool.map((f,i)=>({ file:f, url:URL.createObjectURL(f), kind: f.type.split('/')[0], name:f.name }));
      log('Selezionati', state.picked.length, 'clip');

      $('#progressBox').style.display='block';
      $('#resultBox').style.display='none';
      updateProgress(0,'Preparazione‚Ä¶');

      try{
        const blob = await renderMontage(state);
        const url = URL.createObjectURL(blob);
        const a = $('#downloadLink');
        a.href = url;
        const stamp = new Date().toISOString().replace(/[:.]/g,'');
        a.download = `M2M_reel_${stamp}.${blob.type.includes('webm')?'webm':'mp4'}`;
        $('#resultBox').style.display='block';
        $('#compatNote').style.display='block';
        updateProgress(100,'Fatto');
        $('#progressBox').style.display='none';
      } catch(err){
        console.error(err);
        log('ERRORE:', err.message||err);
        alert('Qualcosa √® andato storto durante il rendering. Vedi Dettagli tecnici.');
        $('#progressBox').style.display='none';
      }
    }

    function updateProgress(pct,text){
      $('#progressFill').style.width = pct+'%';
      $('#progressText').textContent = text || '';
    }

    // === Rendering su Canvas + MediaRecorder ===
    async function renderMontage(cfg){
      const { picked, w, h, fps, perClip, total, crossfade } = cfg;
      const estClips = Math.max(1, Math.min(picked.length, Math.ceil(total/perClip)));
      const timeline = picked.slice(0, estClips);

      const cvs = $('#stage');
      const ctx = cvs.getContext('2d');
      const tmpVideoA = $('#hiddenVideo');
      const tmpVideoB = document.createElement('video'); tmpVideoB.muted = true; tmpVideoB.playsinline = true; tmpVideoB.style.display='none';
      document.body.appendChild(tmpVideoB);

      // WebAudio per portare l'audio nel MediaRecorder
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const dest = ac.createMediaStreamDestination();

      // Stream video dal canvas
      const canvasStream = cvs.captureStream(fps);
      // Uniamo traccia audio (quando presente) allo stream del canvas
      const mixed = new MediaStream([...canvasStream.getVideoTracks(), ...dest.stream.getAudioTracks()]);

      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : (
                   MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' : 'video/webm');
      const rec = new MediaRecorder(mixed, { mimeType: mime, videoBitsPerSecond: 6_000_000 });

      const chunks = [];
      rec.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };
      const done = new Promise(res => { rec.onstop = () => res(new Blob(chunks, { type: mime })); });

      // Helper: carica <video> per file
      const makeVideoEl = async (clip) => new Promise((resolve,reject)=>{
        const v = document.createElement('video');
        v.src = clip.url; v.crossOrigin = 'anonymous'; v.preload='auto'; v.playsinline=true; v.muted=true; // audio gestito via WebAudio
        v.onloadedmetadata = ()=> resolve(v);
        v.onerror = (e)=> reject(new Error('Impossibile caricare '+clip.name));
      });

      // Disegna frame scalando e croppando in 9:16 (cover)
      function drawCover(video){
        const vw = video.videoWidth, vh = video.videoHeight;
        const targetR = w/h; const srcR = vw/vh;
        let dw, dh, dx, dy;
        if(srcR > targetR){ // troppo largo ‚Üí taglio ai lati
          dh = h; dw = h*srcR; dx = (w-dw)/2; dy = 0;
        } else { // troppo alto ‚Üí taglio sopra/sotto
          dw = w; dh = w/srcR; dx = 0; dy = (h-dh)/2;
        }
        ctx.drawImage(video, dx, dy, dw, dh);
      }

      // Carica tutti i video necessari (immagini vengono trasformate in clip video statici)
      updateProgress(10,'Caricamento clip‚Ä¶');
      const items = [];
      for(const clip of timeline){
        if(clip.kind==='image'){
          const img = new Image(); img.src = clip.url; await img.decode();
          items.push({ type:'image', el: img, dur: perClip });
        } else if(clip.kind==='audio'){
          // visual filler nero, audio riprodotto
          items.push({ type:'audio', el: clip, dur: perClip });
        } else {
          const v = await makeVideoEl(clip);
          items.push({ type:'video', el: v, dur: Math.min(perClip, Math.max(0.5, v.duration || perClip)) });
        }
      }

      // Prepara audio chain: useremo una sola sorgente alla volta per semplicit√†
      let currentSource = null;
      const connectAudio = (mediaEl) => {
        try{
          if(currentSource) currentSource.disconnect();
          const src = ac.createMediaElementSource(mediaEl);
          src.connect(dest);
          currentSource = src;
        }catch(err){ log('Audio non collegabile (probabile CORS o clip senza audio):', err.message||err); }
      };

      // Start recorder
      rec.start(1000);

      // Timeline rendering
      cvs.width = w; cvs.height = h; ctx.fillStyle = '#000';

      let tAccum = 0;
      for(let i=0;i<items.length;i++){
        const part = items[i];
        const next = items[i+1];
        updateProgress(10 + Math.round((i/items.length)*80), `Rendering clip ${i+1}/${items.length}`);

        if(part.type==='video'){
          const v = part.el; v.currentTime = 0; await v.play().catch(()=>{});
          connectAudio(v);
          const tEnd = perClip;
          const startTs = performance.now();

          // disegno frame-by-frame per tEnd secondi
          await new Promise((resolve)=>{
            const draw = () => {
              const elapsed = (performance.now()-startTs)/1000;
              ctx.fillRect(0,0,w,h);
              drawCover(v);

              // crossfade semplice con prossimo video negli ultimi X secondi
              if(next && next.type==='video' && (tEnd - elapsed) <= crossfade){
                const alpha = Math.min(1, Math.max(0, (crossfade - (tEnd - elapsed)) / crossfade));
                ctx.save(); ctx.globalAlpha = alpha;
                // preload next video
                if(!next.el.prepared){ next.el.prepared = true; next.el.currentTime = 0; next.el.play().catch(()=>{}); }
                drawCover(next.el);
                ctx.restore();
              }

              if(elapsed < tEnd){ requestAnimationFrame(draw); }
              else { v.pause(); resolve(); }
            };
            requestAnimationFrame(draw);
          });
        }
        else if(part.type==='image'){
          const img = part.el; const tEnd = perClip; const startTs = performance.now();
          await new Promise((resolve)=>{
            const draw = () => {
              const elapsed = (performance.now()-startTs)/1000;
              ctx.fillRect(0,0,w,h);
              // draw image cover
              const ir = img.width/img.height; const tr = w/h;
              let dw,dh,dx,dy; if(ir>tr){ dh=h; dw=h*ir; dx=(w-dw)/2; dy=0; } else { dw=w; dh=w/ir; dx=0; dy=(h-dh)/2; }
              ctx.drawImage(img, dx,dy,dw,dh);
              if(elapsed < tEnd){ requestAnimationFrame(draw); } else resolve();
            };
            requestAnimationFrame(draw);
          });
        }
        else if(part.type==='audio'){
          // frame nero + audio
          ctx.fillRect(0,0,w,h);
          const aud = new Audio(part.file ? URL.createObjectURL(part.file) : part.el.url);
          aud.crossOrigin='anonymous'; aud.loop=false; aud.currentTime=0; await aud.play().catch(()=>{});
          connectAudio(aud);
          await new Promise(res=> setTimeout(res, perClip*1000));
          aud.pause();
        }

        tAccum += perClip;
        if(tAccum >= total) break;
      }

      // stop recorder
      rec.stop();
      await ac.close().catch(()=>{});
      const blob = await done;
      // cleanup
      try{ tmpVideoA.pause(); tmpVideoB.pause(); tmpVideoB.remove(); }catch{}
      return blob;
    }
  </script>
</body>
</html>

