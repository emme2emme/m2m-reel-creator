<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üé¨ M2M Reel Creator ‚Äî Web</title>
  <meta name="theme-color" content="#3498db" />
  <style>
    /* === Stili UI compatti === */
    * { box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); margin:0; padding:10px; color:#333 }
    .container{max-width:520px;margin:0 auto;background:rgba(255,255,255,.96);border-radius:24px;box-shadow:0 20px 40px rgba(0,0,0,.12);overflow:hidden}
    .header{background:linear-gradient(135deg,#2c3e50,#3498db);color:#fff;padding:28px 22px;text-align:center}
    .header h1{margin:0 0 8px;font-size:1.8rem}
    .content{padding:22px}
    .step{margin-bottom:22px}
    .step-header{display:flex;align-items:center;gap:10px;font-weight:700;color:#2c3e50;margin-bottom:10px}
    .step-number{width:32px;height:32px;border-radius:50%;display:grid;place-items:center;color:#fff;background:linear-gradient(135deg,#3498db,#2980b9);box-shadow:0 4px 12px rgba(52,152,219,.3)}
    .card{background:#f8f9fa;border:1px solid #e9ecef;border-radius:14px;padding:14px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .selector{border:2px dashed #dee2e6;border-radius:14px;padding:16px;text-align:center;background:#fff;cursor:pointer}
    .selector.active{border-color:#27ae60;background:#d4edda}
    .label{font-weight:600;color:#2c3e50;margin-bottom:6px}
    .desc{font-size:.85rem;color:#6c757d}
    .slider-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .pill{background:linear-gradient(135deg,#3498db,#2980b9);color:#fff;border-radius:999px;padding:4px 10px;font-weight:700;font-size:.9rem}
    input[type=range]{width:100%}
    .btn{border:0;border-radius:18px;padding:14px 18px;font-weight:800;color:#fff;cursor:pointer;display:flex;gap:8px;align-items:center;justify-content:center}
    .btn-primary{background:linear-gradient(135deg,#27ae60,#229954);box-shadow:0 8px 20px rgba(39,174,96,.28)}
    .btn-secondary{background:linear-gradient(135deg,#f39c12,#e67e22)}
    .muted{font-size:.85rem;color:#6c757d}
    .progress{display:none;margin-top:12px}
    .bar{height:12px;background:#e9ecef;border-radius:6px;overflow:hidden}
    .fill{height:100%;width:0;background:linear-gradient(90deg,#3498db,#2980b9)}
    .center{text-align:center}
    .badge{display:inline-block;background:#fff3cd;color:#856404;border-radius:999px;padding:4px 10px;font-weight:700;font-size:.8rem}
    .row{display:flex;gap:10px;align-items:center}
    .template-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px}
    .template{border:2px solid #e9ecef;border-radius:12px;padding:10px;text-align:center;background:#fff;cursor:pointer}
    .template.active{border-color:#27ae60;background:#d4edda}
    .result{display:none;margin-top:14px;padding:16px;background:#d4edda;border:1px solid #c3e6cb;border-radius:14px}
    .warn{background:#fff3f3;color:#842029;border:1px solid #f5c2c7;border-radius:12px;padding:10px;margin-top:10px}
    .code{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#f1f3f5;padding:10px;border-radius:8px;overflow:auto;font-size:.85rem;max-height:220px}
    details > summary{cursor:pointer}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé¨ M2M Reel Creator</h1>
      <div>Montaggio reale in-browser (Web ‚ü∑ Mobile)</div>
    </div>
    <div class="content">
      <!-- STEP 1: selezione -->
      <div class="step">
        <div class="step-header"><div class="step-number">1</div><div>Carica i tuoi file</div></div>
        <div class="grid2">
          <label class="selector" id="chooseFiles">
            <div class="label">Seleziona File</div>
            <div class="desc">Video / Immagini / Audio</div>
          </label>
          <label class="selector" id="chooseFolder">
            <div class="label">Seleziona Cartella</div>
            <div class="desc">Richiede browser Chromium</div>
          </label>
        </div>
        <div class="row" style="margin-top:8px">
          <div id="fileBadge" class="badge" style="display:none">0 file caricati</div>
          <div class="muted" id="tip">Formati consigliati: .mp4, .mov, .webm, .mkv (video); .jpg/.png (immagini)</div>
        </div>
        <input id="fileInput" type="file" multiple accept="video/*,image/*,audio/*" hidden />
        <input id="folderInput" type="file" webkitdirectory directory multiple accept="video/*,image/*,audio/*" hidden />
      </div>

      <!-- STEP 2: template -->
      <div class="step">
        <div class="step-header"><div class="step-number">2</div><div>Scegli un template</div></div>
        <div class="template-grid">
          <div class="template active" data-tmpl="custom">‚öôÔ∏è<div><b>Personalizzato</b></div><div class="muted">Imposti tu</div></div>
          <div class="template" data-tmpl="viral">üî•<div><b>Viral Reel</b></div><div class="muted">60s ‚Ä¢ clip 3s</div></div>
          <div class="template" data-tmpl="smooth">‚ú®<div><b>Smooth Flow</b></div><div class="muted">90s ‚Ä¢ clip 5s</div></div>
          <div class="template" data-tmpl="burst">‚ö°<div><b>Quick Burst</b></div><div class="muted">30s ‚Ä¢ clip 2s</div></div>
          <div class="template" data-tmpl="cinematic">üé¨<div><b>Cinematic</b></div><div class="muted">120s ‚Ä¢ clip 7s</div></div>
          <div class="template" data-tmpl="story">üì±<div><b>Story Mode</b></div><div class="muted">45s ‚Ä¢ clip 4s</div></div>
        </div>
      </div>

      <!-- STEP 3: impostazioni -->
      <div class="step card">
        <div class="slider-row"><span class="label">Durata finale</span><span class="pill" id="totalOut">60s</span></div>
        <input id="totalRange" type="range" min="15" max="180" step="5" value="60" />
        <div class="slider-row" style="margin-top:10px"><span class="label">Durata clip</span><span class="pill" id="clipOut">4s</span></div>
        <input id="clipRange" type="range" min="2" max="15" step="0.5" value="4" />
        <div class="slider-row" style="margin-top:10px"><span class="label">Clip da usare</span><span class="pill" id="countOut">10</span></div>
        <input id="countRange" type="range" min="3" max="50" step="1" value="10" />
        <div class="muted" style="margin-top:8px">Stima clip: <b id="estClips">15</b></div>
      </div>

      <!-- STEP 4: genera -->
      <div class="step">
        <div class="step-header"><div class="step-number">4</div><div>Crea il tuo montaggio</div></div>
        <button class="btn btn-primary" id="startBtn">üöÄ Crea Video</button>
        <div class="progress" id="progressBox">
          <div class="bar"><div class="fill" id="progressFill"></div></div>
          <div class="center muted" id="progressText">Preparazione‚Ä¶</div>
        </div>
        <div class="result" id="resultBox">
          <div class="center" style="font-size:2rem">üéâ</div>
          <div class="center" style="font-weight:700;color:#155724">Video pronto!</div>
          <div class="center" style="margin-top:10px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap">
            <a id="downloadLink" class="btn btn-secondary" download>üì• Scarica</a>
            <button id="exportMp4Btn" class="btn btn-secondary" style="background:linear-gradient(135deg,#1f7aee,#1558b0)" disabled>üéûÔ∏è Esporta MP4 (H.264)</button>
          </div>
        </div>
        <div class="warn" id="compatNote" style="display:none">
          Suggerimento: il recorder usa il profilo pi√π compatibile disponibile. Se l‚Äôaudio non √® supportato nel profilo WebM del tuo browser, verr√† registrato solo il video.
        </div>
      </div>

      <!-- Popup: file non compatibili -->
      <dialog id="skipDialog" style="max-width:520px;border:0;border-radius:16px;padding:0;">
        <div style="padding:18px 18px 10px;background:#fff;border-radius:16px 16px 0 0;border-bottom:1px solid #eee">
          <div style="font-weight:800;font-size:1.05rem">Alcuni file non sono compatibili</div>
          <div class="muted" style="margin-top:6px">Questi file non verranno inclusi nel montaggio perch√© il browser non pu√≤ riprodurli (codec/container non supportato):</div>
        </div>
        <div style="max-height:240px;overflow:auto;background:#fff;padding:0 18px 12px">
          <pre id="skipList" class="code" style="margin:10px 0 0;max-height:none"></pre>
        </div>
        <div style="display:flex;gap:10px;justify-content:flex-end;padding:12px 18px;background:#f8f9fa;border-top:1px solid #eee;border-radius:0 0 16px 16px">
          <button id="btnCancelSkip" class="btn" style="background:#adb5bd">Annulla</button>
          <button id="btnContinueSkip" class="btn btn-primary">Continua comunque</button>
        </div>
      </dialog>

      <!-- Popup: aiuto MP4 web (fallback) -->
      <dialog id="mp4HelpDialog" style="max-width:560px;border:0;border-radius:16px;padding:0;">
        <div style="padding:18px 18px 10px;background:#fff;border-radius:16px 16px 0 0;border-bottom:1px solid #eee">
          <div style="font-weight:800;font-size:1.05rem">Esporta in MP4 (H.264/AAC)</div>
          <div class="muted" style="margin-top:6px">Se stai usando il sito web su PC, converti il WebM scaricato in MP4 con FFmpeg (Windows):</div>
        </div>
        <div style="background:#fff;padding:12px 18px">
          <div class="muted" style="margin-bottom:8px">Apri PowerShell nella cartella del file e incolla:</div>
          <pre class="code" id="ffmpegCmdBox">ffmpeg -y -i input.webm -vf "scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,format=yuv420p" -r 30 -c:v libx264 -preset veryfast -crf 21 -c:a aac -b:a 160k output.mp4</pre>
        </div>
        <div style="display:flex;gap:10px;justify-content:flex-end;padding:12px 18px;background:#f8f9fa;border-top:1px solid #eee;border-radius:0 0 16px 16px">
          <button id="btnCopyFfmpeg" class="btn" style="background:#27ae60">Copia comando</button>
          <button id="btnCloseMp4Help" class="btn" style="background:#adb5bd">Chiudi</button>
        </div>
      </dialog>

      <!-- Autotest / Diagnostica -->
      <details class="step card">
        <summary><b>Autotest & Dettagli tecnici</b></summary>
        <div class="muted" style="margin-top:8px">
          Questa versione rende via <b>Canvas + MediaRecorder</b> (video) e <b>WebAudio</b> (audio). Ha:
          <ul>
            <li>Filtro clip non riproducibili (codec non supportati) con popup.</li>
            <li>Timeout di caricamento e skip sicuro dei clip problematici.</li>
            <li>Scelta MIME dinamica per evitare l‚Äôerrore su Opus.</li>
          </ul>
        </div>
        <button class="btn btn-secondary" id="runSelfTest">üß™ Esegui Autotest</button>
        <button class="btn btn-secondary" id="simulateIncompatible">üß™ Simula file non compatibili</button>
        <div class="code" id="log"></div>
      </details>

      <!-- Elementi nascosti per il rendering -->
      <video id="hiddenVideo" crossorigin="anonymous" playsinline muted style="display:none"></video>
      <canvas id="stage" width="1080" height="1920" style="display:none"></canvas>
    </div>
  </div>

  <script>
    // === Utility log & helpers ===
    const $ = (sel) => document.querySelector(sel);
    const logBox = $('#log');
    const log = (...args) => { if(logBox) logBox.textContent += args.join(' ') + "\n"; };
    const showDialog = (el) => { try{ el.showModal ? el.showModal() : el.show && el.show(); }catch{ el.open=true; } };
    const closeDialog = (el) => { try{ el.close ? el.close() : (el.open=false); }catch{ el.open=false; } };
    const blobToBase64 = (blob) => new Promise((resolve,reject)=>{ const r=new FileReader(); r.onload=()=>resolve(r.result.split(',')[1]); r.onerror=reject; r.readAsDataURL(blob); });

    // Stato app
    const state = {
      files: [], picked: [],
      template: 'custom',
      total: 60, perClip: 4, count: 10,
      fps: 30, w: 1080, h: 1920,
      crossfade: 0.4,
      lastBlob: null
    };

    // Support check
    const supports = { mediaRecorder: !!window.MediaRecorder, canPlay: document.createElement('video') };

    // UI wiring
    $('#chooseFiles').onclick = () => $('#fileInput').click();
    $('#chooseFolder').onclick = () => $('#folderInput').click();
    $('#fileInput').onchange = (e) => ingest(Array.from(e.target.files));
    $('#folderInput').onchange = (e) => ingest(Array.from(e.target.files));

    document.querySelectorAll('.template').forEach(el => {
      el.onclick = () => {
        document.querySelectorAll('.template').forEach(e => e.classList.remove('active'));
        el.classList.add('active');
        state.template = el.dataset.tmpl;
        applyTemplate();
      }
    });

    $('#totalRange').oninput = (e) => { state.total = +e.target.value; $('#totalOut').textContent = state.total + 's'; estimate(); };
    $('#clipRange').oninput = (e) => { state.perClip = +e.target.value; $('#clipOut').textContent = state.perClip + 's'; estimate(); };
    $('#countRange').oninput = (e) => { state.count = +e.target.value; $('#countOut').textContent = state.count; estimate(); };

    $('#startBtn').onclick = start;
    $('#runSelfTest').onclick = runSelfTest;
    const simBtn = document.getElementById('simulateIncompatible');
    if (simBtn) simBtn.onclick = simulateIncompatible;
    document.getElementById('exportMp4Btn').onclick = exportToMp4;

    // Dialog MP4 help
    const mp4Dlg = document.getElementById('mp4HelpDialog');
    const btnCopy = document.getElementById('btnCopyFfmpeg');
    const btnClose = document.getElementById('btnCloseMp4Help');
    if(btnCopy) btnCopy.onclick = () => {
      const txt = document.getElementById('ffmpegCmdBox').innerText;
      navigator.clipboard?.writeText(txt);
    };
    if(btnClose) btnClose.onclick = () => closeDialog(mp4Dlg);

    // Mappa estensioni ‚Üí mime probabile
    const ext2mime = (name) => {
      const n = name.toLowerCase();
      if(n.endsWith('.mp4')||n.endsWith('.m4v')) return 'video/mp4';
      if(n.endsWith('.mov')) return 'video/quicktime';
      if(n.endsWith('.webm')) return 'video/webm';
      if(n.endsWith('.mkv')) return 'video/x-matroska';
      if(n.endsWith('.jpg')||n.endsWith('.jpeg')) return 'image/jpeg';
      if(n.endsWith('.png')) return 'image/png';
      if(n.endsWith('.gif')) return 'image/gif';
      if(n.endsWith('.webp')) return 'image/webp';
      if(n.endsWith('.mp3')) return 'audio/mpeg';
      if(n.endsWith('.wav')) return 'audio/wav';
      return '';
    };

    function canBrowserPlay(file){
      const mime = file.type || ext2mime(file.name);
      if(!mime) return true;
      if(mime.startsWith('video/')){
        const res = supports.canPlay.canPlayType(mime);
        return res === 'probably' || res === 'maybe';
      }
      return true;
    }

    function ingest(files){
      const mm = files.filter(f => /^(video|image|audio)\//.test(f.type) || /\.(mp4|mov|webm|mkv|m4v|jpg|jpeg|png|gif|bmp|webp|mp3|wav)$/i.test(f.name));
      const playable = mm.filter(canBrowserPlay);
      const skipped = mm.length - playable.length;
      state.files = playable;
      $('#fileBadge').style.display = 'inline-block';
      $('#fileBadge').textContent = `${playable.length} file caricati${skipped?` (saltati ${skipped} non supportati)`:''}`;
      log('Caricati', playable.length, 'file. Saltati:', skipped);
    }

    function applyTemplate(){
      const t = state.template;
      if(t==='viral'){ state.total=60; state.perClip=3; }
      else if(t==='smooth'){ state.total=90; state.perClip=5; }
      else if(t==='burst'){ state.total=30; state.perClip=2; }
      else if(t==='cinematic'){ state.total=120; state.perClip=7; }
      else if(t==='story'){ state.total=45; state.perClip=4; }
      $('#totalRange').value = state.total; $('#totalOut').textContent = state.total+'s';
      $('#clipRange').value = state.perClip; $('#clipOut').textContent = state.perClip+'s';
      estimate();
    }

    function estimate(){ $('#estClips').textContent = Math.ceil(state.total / state.perClip); }
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j]]; } return arr; }

    // === Helper: scelta MIME sicura per MediaRecorder ===
    function pickRecorderMime(wantsAudio = true){
      const withAudio = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus'];
      const noAudio   = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];
      const list = wantsAudio ? withAudio : noAudio;
      for(const m of list){
        try { if (MediaRecorder.isTypeSupported(m)) return m; } catch {}
      }
      return null;
    }

    async function start(){
      if(!supports.mediaRecorder){
        alert('Questo browser non supporta MediaRecorder. Usa Chrome/Edge desktop, oppure la versione nativa.');
        return;
      }
      if(state.files.length===0){ alert('Carica prima dei file.'); return; }

      const pool = shuffle([...state.files]).slice(0, Math.min(state.count, state.files.length));

      const picked = [];
      const skippedNames = [];
      for(const f of pool){
        const ok = await probeVideoOrMedia(f);
        if(ok){ picked.push(ok); }
        else { skippedNames.push(f.name); log('‚ö†Ô∏è Clip saltato per problemi di caricamento/codec:', f.name); }
      }

      if(picked.length===0){
        alert('Nessun clip riproducibile. Prova con MP4 H.264/AAC o WEBM VP8/VP9.');
        return;
      }

      if(skippedNames.length){
        const proceed = await confirmProceedSkipped(skippedNames);
        if(!proceed){ return; }
      }

      state.picked = picked;
      log('Selezionati', state.picked.length, 'clip');

      $('#progressBox').style.display='block';
      $('#resultBox').style.display='none';
      updateProgress(0,'Preparazione‚Ä¶');

      try{
        const blob = await renderMontage(state);
        const url = URL.createObjectURL(blob);
        const a = $('#downloadLink');
        a.href = url;
        const stamp = new Date().toISOString().replace(/[:.]/g,'');
        a.download = `M2M_reel_${stamp}.${blob.type.includes('webm')?'webm':'mp4'}`;
        state.lastBlob = blob;
        document.getElementById('exportMp4Btn').disabled = false;
        $('#resultBox').style.display='block';
        $('#compatNote').style.display='block';
        updateProgress(100,'Fatto');
        $('#progressBox').style.display='none';
      } catch(err){
        console.error(err);
        log('ERRORE:', err.message||err);
        alert('Errore durante il rendering. Apri "Autotest & Dettagli tecnici" per i log.');
        $('#progressBox').style.display='none';
      }
    }

    function updateProgress(pct,text){ $('#progressFill').style.width = pct+'%'; $('#progressText').textContent = text || ''; }

    // Popup informativo su file non compatibili
    function confirmProceedSkipped(names){
      return new Promise((resolve)=>{
        const dlg = document.getElementById('skipDialog');
        const list = document.getElementById('skipList');
        const maxShow = 30;
        const extra = names.length>maxShow ? `\n‚Ä¶ e altri ${names.length-maxShow} file` : '';
        list.textContent = names.slice(0,maxShow).join('\n') + extra;
        const onCancel = () => { closeDialog(dlg); cleanup(); resolve(false); };
        const onOk = () => { closeDialog(dlg); cleanup(); resolve(true); };
        function cleanup(){
          document.getElementById('btnCancelSkip').removeEventListener('click', onCancel);
          document.getElementById('btnContinueSkip').removeEventListener('click', onOk);
        }
        document.getElementById('btnCancelSkip').addEventListener('click', onCancel);
        document.getElementById('btnContinueSkip').addEventListener('click', onOk);
        if(typeof dlg.showModal === 'function'){ dlg.showModal(); }
        else { alert('File non compatibili:\n' + list.textContent); resolve(confirm('Vuoi continuare?')); }
      });
    }

    // Simulatore: crea un file non supportato per testare il popup
    function simulateIncompatible(){
      const bad = new File([new Uint8Array([0,1,2,3])], 'clip_hevc_like.mp4', { type: 'video/mp4' });
      const ok1 = new File([new Uint8Array([1,2,3,4])], 'ok_a.webm', { type: 'video/webm' });
      const ok2 = new File([new Uint8Array([2,3,4,5])], 'ok_b.webm', { type: 'video/webm' });
      ingest([bad, ok1, ok2]);
      start();
    }

    // === Probe robusto: tenta caricamento video/immagine/audio ===
    async function probeVideoOrMedia(file){
      const url = URL.createObjectURL(file);
      const kindGuess = (file.type || ext2mime(file.name) || '').split('/')[0];
      try{
        if(kindGuess==='image'){
          const img = new Image(); img.src = url; await img.decode();
          return { file, url, kind:'image', name:file.name, revoke:() => URL.revokeObjectURL(url) };
        }
        if(kindGuess==='audio'){
          return { file, url, kind:'audio', name:file.name, revoke:() => URL.revokeObjectURL(url) };
        }
        const v = document.createElement('video');
        v.src = url; v.crossOrigin='anonymous'; v.preload='metadata'; v.playsinline = true; v.muted = true;
        const ok = await waitVideoReady(v, 6000);
        if(!ok){ URL.revokeObjectURL(url); return null; }
        return { file, url, kind:'video', name:file.name, revoke:() => URL.revokeObjectURL(url) };
      } catch(e){
        URL.revokeObjectURL(url);
        return null;
      }
    }

    function waitVideoReady(v, timeoutMs=6000){
      return new Promise((resolve)=>{
        let done=false; const to = setTimeout(()=>{ if(!done){ done=true; resolve(false);} }, timeoutMs);
        const clean = () => { if(done) return; done=true; clearTimeout(to); resolve(true); };
        v.onloadedmetadata = clean; v.oncanplay = clean; v.oncanplaythrough = clean;
        v.onerror = () => { if(!done){ done=true; clearTimeout(to); resolve(false);} };
      });
    }

    // === Rendering su Canvas + MediaRecorder ===
    async function renderMontage(cfg){
      const { picked, w, h, fps, perClip, total, crossfade } = cfg;
      const estClips = Math.max(1, Math.min(picked.length, Math.ceil(total/perClip)));
      const timeline = picked.slice(0, estClips);

      const cvs = document.getElementById('stage');
      const ctx = cvs.getContext('2d');
      cvs.width = w; cvs.height = h; ctx.fillStyle = '#000';

      // Un solo AudioContext + destinazione
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      await ac.resume();
      const dest = ac.createMediaStreamDestination();

      // Stream video dal canvas
      const canvasStream = cvs.captureStream(fps);

      // Scegli un MIME compatibile: prova con audio Opus, altrimenti solo video
      let mime = pickRecorderMime(true);
      let includeAudio = true;
      if(!mime){ mime = pickRecorderMime(false); includeAudio = false; }
      if(!mime) throw new Error('Nessun MIME supportato da MediaRecorder per WebM.');

      // Costruisci lo stream finale
      let tracks = [...canvasStream.getVideoTracks()];
      if(includeAudio){
        tracks.push(...dest.stream.getAudioTracks());
      } else {
        log('‚ö†Ô∏è Audio escluso perch√© il MIME selezionato non supporta opus:', mime);
        const note = document.getElementById('compatNote');
        if (note) note.style.display = 'block';
      }
      const mixed = new MediaStream(tracks);

      // Recorder
      const rec = new MediaRecorder(mixed, { mimeType: mime, videoBitsPerSecond: 6_000_000 });
      const chunks = [];
      rec.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };
      const done = new Promise(res => { rec.onstop = () => res(new Blob(chunks, { type: mime })); });
      rec.start(1000);

      // Prepara elementi
      updateProgress(10,'Caricamento clip‚Ä¶');
      const items = [];
      for(const clip of timeline){
        if(clip.kind==='image'){
          const img = new Image(); img.src = clip.url; await img.decode();
          items.push({ type:'image', el: img, dur: perClip, revoke: clip.revoke });
        } else if(clip.kind==='audio'){
          items.push({ type:'audio', el: clip, dur: perClip, revoke: clip.revoke });
        } else {
          const v = document.createElement('video');
          v.src = clip.url; v.crossOrigin = 'anonymous'; v.preload='auto'; v.playsinline=true; v.muted=false;
          const ready = await waitVideoReady(v, 6000);
          if(!ready){ log('‚ö†Ô∏è Skip clip non pronto:', clip.name); clip.revoke?.(); continue; }
          items.push({ type:'video', el: v, name: clip.name, dur: Math.max(0.5, Math.min(perClip, v.duration||perClip)), revoke: clip.revoke });
        }
      }

      if(items.length===0){ rec.stop(); await ac.close().catch(()=>{}); throw new Error('Nessun clip valido dopo il caricamento.'); }

      let currentSource = null;
      let tAccum = 0;

      function drawCover(video){
        const vw = video.videoWidth||1, vh = video.videoHeight||1;
        const targetR = w/h; const srcR = vw/vh;
        let dw, dh, dx, dy;
        if(srcR > targetR){ dh = h; dw = h*srcR; dx = (w-dw)/2; dy = 0; }
        else { dw = w; dh = w/srcR; dx = 0; dy = (h-dh)/2; }
        ctx.drawImage(video, dx, dy, dw, dh);
      }

      for(let i=0;i<items.length;i++){
        const part = items[i];
        const next = items[i+1];
        updateProgress(10 + Math.round((i/items.length)*80), `Rendering clip ${i+1}/${items.length}`);

        if(part.type==='video'){
          const v = part.el; v.currentTime = 0; await v.play().catch(()=>{});
          if(currentSource) try{ currentSource.disconnect(); }catch{}
          try{ currentSource = ac.createMediaElementSource(v); currentSource.connect(dest); }catch{}
          const tEnd = part.dur; const startTs = performance.now();
          await new Promise((resolve)=>{
            const draw = () => {
              const elapsed = (performance.now()-startTs)/1000;
              ctx.fillRect(0,0,w,h);
              drawCover(v);
              if(next && next.type==='video' && (tEnd - elapsed) <= crossfade){
                const alpha = Math.min(1, Math.max(0, (crossfade - (tEnd - elapsed)) / crossfade));
                ctx.save(); ctx.globalAlpha = alpha;
                if(!next.el.prepared){ next.el.prepared = true; next.el.currentTime = 0; next.el.play().catch(()=>{}); }
                drawCover(next.el);
                ctx.restore();
              }
              if(elapsed < tEnd){ requestAnimationFrame(draw); }
              else { v.pause(); resolve(); }
            };
            requestAnimationFrame(draw);
          });
        } else if(part.type==='image'){
          const img = part.el; const tEnd = part.dur; const startTs = performance.now();
          if(currentSource) try{ currentSource.disconnect(); }catch{}
          await new Promise((resolve)=>{
            const draw = () => {
              const elapsed = (performance.now()-startTs)/1000;
              ctx.fillRect(0,0,w,h);
              const ir = img.width/img.height; const tr = state.w/state.h;
              let dw,dh,dx,dy; if(ir>tr){ dh=h; dw=h*ir; dx=(w-dw)/2; dy=0; } else { dw=w; dh=w/ir; dx=0; dy=(h-dh)/2; }
              ctx.drawImage(img, dx,dy,dw,dh);
              if(elapsed < tEnd){ requestAnimationFrame(draw); } else resolve();
            };
            requestAnimationFrame(draw);
          });
        } else if(part.type==='audio'){
          if(currentSource) try{ currentSource.disconnect(); }catch{}
          const aud = new Audio(part.el.url); aud.crossOrigin='anonymous'; aud.loop=false; aud.currentTime=0; await aud.play().catch(()=>{});
          try{ currentSource = ac.createMediaElementSource(aud); currentSource.connect(dest); }catch{}
          ctx.fillRect(0,0,w,h);
          await new Promise(res=> setTimeout(res, part.dur*1000));
          aud.pause();
        }

        tAccum += part.dur;
        part.revoke?.();
        if(tAccum >= total) break;
      }

      rec.stop();
      const blob = await done;
      await ac.close().catch(()=>{});
      return blob;
    }

    // === Autotest: genera 2 clip colorati e prova la pipeline ===
    async function runSelfTest(){
      log('--- AUTOTEST ---');
      if(!supports.mediaRecorder){ log('‚ùå MediaRecorder non supportato'); alert('MediaRecorder non supportato in questo browser.'); return; }
      const blobs = [];
      for(const color of ['#d6336c','#1c7ed6']){
        const c = document.createElement('canvas'); c.width=640; c.height=360; const cx=c.getContext('2d');
        const s = c.captureStream(30); const mr = new MediaRecorder(s, {mimeType: pickRecorderMime(false) || 'video/webm'});
        const cs=[]; mr.ondataavailable=(e)=>{ if(e.data.size) cs.push(e.data); };
        mr.start(200);
        const t0=performance.now();
        await new Promise(res=>{
          const draw=()=>{ cx.fillStyle=color; cx.fillRect(0,0,c.width,c.height); if(performance.now()-t0<1500){ requestAnimationFrame(draw);} else { mr.stop(); res(); } };
          draw();
        });
        const blob = await new Promise(res=>{ mr.onstop=()=>res(new Blob(cs,{type: mr.mimeType || 'video/webm'})); });
        blobs.push(new File([blob], `auto_${color.replace('#','')}.webm`, {type:'video/webm'}));
      }
      ingest(blobs);
      await start();
    }

    // === Export MP4 (H.264) ===
    async function exportToMp4(){
      try{
        if(!state.lastBlob){ alert('Crea prima un video (WebM), poi esporta.'); return; }
        const cap = window.Capacitor;
        const isNative = !!(cap && cap.isNativePlatform);
        const Plugins = cap?.Plugins || {};
        const Filesystem = Plugins.Filesystem || window.Filesystem;
        const FFmpegKit = Plugins.FFmpegKit || window.FFmpegKit || Plugins?.FFmpegKitPlugin;

        if(isNative && Filesystem && FFmpegKit){
          const b64 = await blobToBase64(state.lastBlob);
          const inputName = `m2m_input_${Date.now()}.webm`;
          const outputName = `m2m_output_${Date.now()}.mp4`;
          await Filesystem.writeFile({ path: inputName, data: b64, directory: 'CACHE' });
          const inPath = (await Filesystem.getUri({ path: inputName, directory: 'CACHE' })).uri;
          const outPath = (await Filesystem.getUri({ path: outputName, directory: 'CACHE' })).uri;
          const cmd = `-y -i "${inPath}" -vf scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2,format=yuv420p -r 30 -c:v libx264 -preset veryfast -crf 21 -c:a aac -b:a 160k "${outPath}"`;
          const sess = await FFmpegKit.execute(cmd);
          const rc = sess?.getReturnCode?.() || sess?.returnCode || 0;
          if(rc && rc.value && rc.value !== 0){ throw new Error('FFmpegKit RC '+rc.value); }
          alert('MP4 esportato in Cache: '+ outputName + '\nApri l\'app File/Condividi per recuperarlo.');
        } else {
          showDialog(document.getElementById('mp4HelpDialog'));
        }
      }catch(err){
        console.error(err);
        alert('Export MP4 non riuscito: '+ (err.message||err));
      }
    }
  </script>
</body>
</html>

